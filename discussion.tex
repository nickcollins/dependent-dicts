\section{Discussion and Related Work}
\label{sec:Discussion}

\vspace{0.05in} %% SPACE HACK

%% \parahead{Association Lists and Partial Functions}
%% \parahead{Conventional Dictionary Representations}

\parahead{Conventional Representations}
%
Due to their simplicity, {\sal}s are perhaps the most typical implementation for dictionaries.
%
But because \SemInj{} is so important in simplifying proofs, {\FPF}s also see significant use---in key works such as \emph{Software Foundations}~\cite[Maps]{Pierce:SF1}---despite requiring a bit of extra overhead.

%% TODO macro?

\Cals{} seem to get little use, perhaps because working with refinement proofs might add more hassle than \SemInj{} alleviates.
%
\Cals{} are defined in the Coq standard library as \texttt{FMapList} \citep{FMapList}; a GitHub search for \texttt{FMapList} shows $304$ results,
%
whereas a search for \texttt{FMapAVL} shows $474$ results, suggesting that {\cal}s have been found to be less useful than high-performance implementations.
%
A search for \texttt{FunctionalExtensionality}, on the other hand, turns up $4916$ results, though most of these are probably unrelated to dictionaries.\footnote{
%
\rkc{URLs for the searches?}
%
Accessed August 23, 2020.
%
}
%
\citep{Amorim:fmap} provides a more comprehensive treatment of {\cal}s, augmenting them with a functional interface so that the client can
%
use them as though they were {\fpf}s.

% github searches
% funext        : 4916
% FMapInterface : 504
% FMapAVL       : 474
% FMapList      : 304

\parahead{Dictionaries vs. Custom Datatypes}

Dictionaries are not always used to represent environments in mechanizations of programming language theory.

When the order of bindings does not matter, dictionaries are a natural choice for type contexts.
%
But if types defined ``later,'' or in inner scopes, can refer to types defined ``earlier,'' or in outer scopes, then order-insensitive dictionaries are inherently inappropriate.
%
This is the case for languages that support subtyping (notably, the subject of the POPLMark challenge~\citep{XXX}).
%
Linear logics, on the other hand, require sensitivity to duplicate insertions, so duplication-insensitive dictionaries are inappropriate for them as well.
%
Though {\sal}s remain the most natural choice in these cases, future work could explore data structures that are sensitive to ordering but not duplication, or vice versa.

The use of dictionaries is furthermore avoided in many systems that use substitution rather than environments
%
in defining the dynamic semantics of a language.

For these reasons, many existing mechanizations make little use of order-and-duplication-insensitive dictionaries. 
%
However, as mechanization becomes increasingly popular, for an ever-broadening scope of applications,
%
it seems inevitable that a programming utility as fundamental as dictionaries will eventually become ubiquitous, at which point it will be important to have the
%
best implementations at our disposal.

\parahead{Performance Concerns}
%
It was noted above that AVL implementations are apparently more popular than {\cal}s, and as more software is mechanized, performance is likely to become an
%
even greater concern than it is today. In cases where there is no extraction step, and the proof language is also the language that will be executed,
%
there may be no choice but to use implementations that are high-performance but theoretically unwieldy. However, it seems more appropriate, especially with
%
fundamental utilities such as dictionaries, to either extract or transpile the mechanization into an implementation language that defines these utilities natively
%
by way of highly efficient implementations such as hashtables or red-black trees. This extraction may not be completely fidelitous, since it will be using a
%
different data structure in the implementation than was used in the proofs, but presumably the implementation's version of dictionaries is well-tested and bug-free,
%
and its definition of equality is, at least for fundamental utilities such as dictionaries, extensional and decidable. Regardless, even if unperformant implementations
%
cannot be used for code that will be run, they may be useful for parts of the code which are only used for proofs and will not be executed.

\parahead{Conclusion}
%
This paper discusses the important properties \SemTot, \SemInj, \EqDec, and \EzDstr, and offers an implementation for dictionaries that (mostly) fulfills these properties.
%
Future work could consider implementations for other key utilities, such as trees or graphs, that satisfy these properties.
%
Doing so could be far more challenging.
%
It is relatively easy to simultaneously satisfy \SemTot{} and \SemInj{} for list-like structures such as dictionaries,
%
but much more awkward to do so for highly structural data such as graphs. For graphs in particular, establishing a one-to-one correspondence between terms and
%
semantic meanings requires understanding of the graph isomorphism problem, which besides being NP-hard, involves complex algebra.

% Other things to consider mentioning, but probably not
% - try to make sense of https://github.com/arthuraa/coq-utils/blob/master/theories/nominal.v
% - Coq also has FMapPositive, which is a tree based on the binary representation
% - something something explicit substitutions, Abadi et al. POPL 1990.
% - Look deeper into TDD with Idris
