%% \section{Delta Dictionaries}
\section{Implementation}
\label{sec:DD}

\input{fig-dd-example-all}

This section covers the Agda implementation of the core functionality of \dds, and also defines the key theorems. Additional theorems and functionality, as well as the Agda proofs of the theorems, are not included but are available on github at \citep{github:agda}.

%% \subsection{Delta Indexing}
%% \subsection{Key Types and Deltas}
\subsection{Deltas and Key Types}

Borrowing from association lists, \dds{} use a list-of-pairs, where the first item in each list represents a key and the second is the literal value that is mapped to the represented key.
%
Unlike association lists, the natural number that represents the key is not its literal value.

In order to allow multiple key types, while relying on useful properties of natural numbers under the hood, \dds{} accept a typeclass argument representing a bijection
%
between the key type and the naturals, and use this bijection to convert keys to and from naturals. This is discussed further in \emph{\textbf{Bijections to Natural Numbers}}.

In order to maintain canonical order, while ensuring that every natural number is valid as the first item in a pair, that number must be the non-negative difference between the key it represents and the previous key.
%
This number is called a \emph{delta}. % , alluding to the \emph{delta encoding} technique more commonly harnessed for performance optimization.
%
As described so far, a $0$ offset would correspond to a duplicate key.
%
To prevent duplicate keys from being represented, a delta is actually the offset minus $1$: a delta of $0$ indicates an offset (from the previous key) of $1$, a delta of $2$ indicates an offset of $3$, and so on.
%
The head of the list, however, does not follow the ``minus $1$'' rule: so the first ``delta'' is interpreted literally, \ie{}~it represents the key value exactly.

\autoref{fig:dd-example} depicts the \dd{} corresponding to the example from \autoref{sec:Introduction}.

%% \subsection{Bijections to the naturals}
%% \label{sec:DD:bij}
\parahead{Bijections to Natural Numbers}

In this implementation, each key is represented by a natural number, permitting the use of addition, subtraction, and successor\footnote{The successor of $n$ is $n+1$.} operations for defining deltas.
%
There may be an algebraic structure more general than the natural numbers which satisfies these requirements, but for practical purposes, working with naturals
%
is easier for both the implementer and the client. In Agda, the bijection typeclass accepts a \texttt{convert} function (for clarity, the code in this paper uses the synonym \texttt{toNat}), as well as proofs that \texttt{convert}
%
is injective and surjective, and the inverse function is defined by the library using the proof of surjectivity.\footnote{\hspace{0.01in}%
%
Without surjectivity, a binding for an unmapped natural either invalidates the \dd, violating \Total, or is ignored, in which case its presence or absence does not affect the semantic meaning, violating \Extensional.
%
}
%
The github repo \citep{github:agda} demonstrates this by providing an instance of the bijection typeclass for integers ($25$ lines of code).

Most types that are suitable for use as keys in the first place, especially strings and numeric types, can be bijected to the naturals,
%
though doing so may be onerous. Finite types, such as characters, are suitable as keys, but cannot be bijected to the naturals ---
%
simultaneously achieving \Total{} and \Extensional{} for a dictionary over finite types may require a custom-made dictionary data type.

\Ddls{} are canonically ordered, but by the natural ordering of the naturals, which, depending on the choice of bijection, may correspond to an unnatural
%
ordering of the key type. As such, the ordering is not exposed to the client --- functions such as \texttt{destruct} and \texttt{dlt$\Rightarrow$list} produce results
%
that are in arbitrary order from the client's perspective.

%%, and so from the client's perspective, the \dd{} is unordered.

\subsection{Lookup, Insertion, and Destruction}
\label{sec:DD:basics}

\input{fig-agda}

\autoref{fig:dd-example-find} and \autoref{fig:dd-example-insert} illustrate example lookup and insert operations.
%
These proceed largely as they would for association lists, but working indirectly with keys encoded as natural numbers and, furthermore, differences between these numbers.

\autoref{fig:agda} presents concrete implementations for lookup (\ie{} \texttt{\_\altLAng\_\altRAng}), insert (\ie{} \texttt{\_,,\_}), and \texttt{destruct} in Agda.
%
Note that the lookup function \texttt{\_\altLAng\_\altRAng} takes two args, dictionary \texttt{d} and key \texttt{k}, with the syntax \texttt{d \altLAng{} k \altRAng}.
%
Also note that the \texttt{Delta} module is parameterized by key type \verb+K+ and bijection \verb+bij+ to the naturals, while the operations are parameterized by value type \verb+V+.
%
%Having to treat the first delta differently than the rest (literally rather than relatively) is the source of the somewhat technical---through simple---details.
%
The type \verb+DL+ describes the raw ``delta lists'' used internally, which are wrapped by the \verb+DD+ datatype exposed to clients.

The helper function \verb+delta+ computes the delta, \ie{} the offset minus $1$, between two distinct numbers.
%
Given that, lookup is straightforward. The insert function is also fairly straightforward.
%
If the delta to insert is less than the delta of the first pair, then we place the delta to insert as the first pair of the new list, and
%
the original first pair will be the second pair of the new list, but using the delta between its original value and the inserted delta.
%
If the first pair is an exact match, then we simply replace the old value with the new one.
%
\verb+destruct+ simply pops the head off the list, and then augments the next key by the offset.

%% \cite[Facts about weak maps]{FMapFacts}
%
The Coq Standard Library~\citep{FMapInterface,FMapFacts} describes key theorems about dictionaries, including those for lookup and insert (it does not define \verb+destruct+).
%
The github repo \citep{github:agda} proves the relevant subset of these theorems. Some of the theorems in the Coq treatment involves concepts not relevant to this treatment,
%
especially multiple distinct notions of equality. Also, since this interface does not expose mapping order to the client,
%
there are no proofs of any of the theorems pertaining to ordering (\ie{} those that are not ``weak'').


\subsection{Additional Operations}

The github repo \citep{github:agda} also defines key deletion, union, map, and to/from-list operations, along with appropriate theorems (not reproduced here).

\subsection{Properties}
\input{fig-properties}

\autoref{fig:properties} shows definitions of the four properties identified in \autoref{sec:Introduction:props}, as well as two important consequences of \Extensional{} that will be discussed further in \autoref{sec:CaseStudy}.
%
The proofs of these theorems can be found in the github repo \citep{github:agda}.
%
Recall that key type \verb+K+ is a module parameter and is implicitly bound in the type \verb+DD V+.
