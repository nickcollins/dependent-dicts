%% \section{Delta Dictionaries}
\section{Implementation}
\label{sec:DD}

\subsection{Delta Indexing}

Borrowing from association lists, \dds~ use a list-of-pairs, where the first item in each list represents
a key and the second is the literal value that is mapped to the represented key. Unlike association lists,
the natural number that represents the key is not its literal value. In order to maintain canonical order,
while ensuring that every natural number is valid as the first item in a pair, that number must represent
the non-negative difference between the key it represents and the previous key. We call this a "delta",
alluding to the technique of \emph{delta encoding} which is more commonly harnessed for performance
optimization (TODO source). If the number is $0$, we get duplicate keys - to prevent this, the offset is
actually the delta plus $1$, so that a delta of $0$ indicates an offset (from the previous key) of $1$,\
whereas a delta of $2$ indicates an offset of $3$. The head of the list does not follow the "plus $1$"
rule, so the very first "delta" is interpreted literally, i.e. it represents a key of its exact
value.


\input{fig-dd-example}
\input{fig-dd-example-find}
\input{fig-dd-example-insert}


%% \subsection{Bijections to the naturals}
%% \label{sec:DD:bij}
\parahead{Bijections to the naturals}
Note that the above definitions are in terms of a seemingly arbitrary key type,
and use a function \texttt{convert} to convert terms of that type into naturals.
In Agda, our \dd~ module accepts two parameters - the first is the key type \texttt{Key},
and the second is a type-class \texttt{bij}, whose three members are a \texttt{convert}
function that takes \texttt{Key}s to naturals, and proofs that \texttt{convert} is
injective and surjective. Thus, any key type can be used, as long as the developer
can define a function that converts it to a natural, and prove that that function is
bijective. As an example, we define a \texttt{bij} instance for integers. Other common
key types, such as other numeric types or strings, should be reasonably straightforward
to support. TODO further discussion about how this might be onerous for other key types,
like trees or ADTs. TODO discussion about how this won't work for finite types, like
characters, because we need a true bijection.

Although most types that are suitable for use as keys in the first place can be bijected to the
naturals, for some types defining this bijection may be too awkward or cumbersome, in which case \dds~ may
be a poor choice.

\subsection{Lookup and Insertion}
\label{sec:DD:basics}
The basic functionality of dictionaries are lookup and insertion - they are defined as follows
(TODO):

\input{fig-haskell}

The core theorems for lookup and insertion are as follows (TODO):

\subsection{Destruction}

\rkc{move a bunch of that material from Case Study to here}

\subsection{Additional Operations}

Our Agda mechanization also defines key deletion, union, map, and to/from-list operations, along
with appropriate metatheory (not reproduced here).



%% \subsection{Core properties}
\section{Properties}
\label{sec:DD:props}

\subsection{Design Goals}

The \SemInj~ and \EqDec~ theorems, a destruction theorem, and analogs to \emph{contraction} and
\emph{exchange} are defined below, and proven in Agda. \SemTot~ cannot be formally defined - rather
its truth is apparent from the fact that the other theorems do not require their \dd~ arguments to
be refined with validity premises.

\begin{proposition}[\SemTot]

\breakAndIndent
%
\rkc{Blah}

\end{proposition}

\begin{theorem}[\SemInj]
\label{thm:SemInj}

\breakAndIndent
%
For any \dds~ $D_1$ and $D_2$,
%
if for all $k$, $D_1[k] = D_2[k]$,
%
then $D_1 = D_2$.

\end{theorem}

\begin{theorem}[\EqDec]
\label{thm:EqDec}

\breakAndIndent
%
For any \dds~ $D_1$ and $D_2$ whose values are of type $V$,
%
given a function that decides equality for type $V$,
%

\justIndent
%
we can decide that either $D_1 = D_2$ or $D_1 \ne D_2$.

\end{theorem}

\begin{theorem}[\EzDstr]
\label{thm:EzDstr}

\breakAndIndent
%
For any \dd~ $D$,

\justIndent \quad
%
either $D = \emptyset$ OR

\justIndent \quad
%
there exist $D'$, $k \notin D'$, and $v$
%
s.t. $D = D' , (k, v)$.

\end{theorem}

\subsection{Contraction and Exchange}

\rkc{Two common properties for PL metatheory.}

\begin{theorem}[Dictionary Contraction]
\label{thm:cont-dicts}

\breakAndIndent
%
For any {\dd}~ $D$,
%
$D, (k, v'), (k, v) = D, (k, v)$.

\end{theorem}

\begin{theorem}[Dictionary Exchange]
\label{thm:exch-dicts}

\breakAndIndent
%
For any {\dd}~ $D$,
%
if $k_1 \ne k_2$, then
%
$D, (k_1, v_1), (k_2, v_2) = D, (k_2, v_2), (k_1, v_1)$.

\end{theorem}
