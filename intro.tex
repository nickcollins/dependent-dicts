\section{Introduction}
\label{sec:Introduction}

\newcommand{\firstUseGoal}[1]
  %% {\emph{#1}}
  %% {\textbf{#1}}
  {\textbf{\emph{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \rkc{Part 1.1: Motivation and SAL/CAL/FPF. Editing TBD.}

\subsection{Background}

This paper assumes familiarity with statically typed functional languages (\eg{} Haskell, OCaml), and relevant concepts such as Hindley-Milner type systems, pattern-matching, data types, and product types.
%
A cursory background on \emph{proof assistants} and \emph{dependent types} is developed during the course of this introduction, but unfamiliar readers are encouraged to review a more thorough treatment such as \citep{plfa} or \citep{Pierce:SF1}.

A \emph{proof assistant} is a programming language with first-class support for defining and proving theorems, together with editor tools that ease the development of proofs.
%
Many popular proof languages, including Coq and Agda, are founded on \emph{dependent types}, in which a type can be parameterized by concrete values such as numbers, lists, or functions,
%
and in which theorems are types, proofs are functions (or other concrete values), and type checking subsumes proof checking.

In most programming contexts, the design of data structures and algorithms is chiefly focused on performance, but in dependently-typed proof assistants, evaluation performance is often unimportant since checking a proof requires type-checking but not actual evaluation.
%
As such, proof assistants often use entirely different data structures than those of conventional settings, with a focus on simplicity or useful proof-theoretic properties.

This paper considers several approaches to implementing \emph{dictionaries}, \ie{} finite mappings from keys to values.
%
The dictionary is a fundamental utility in most programming contexts and serves a broad range of purposes, so the choice of implementation is very important.
%
In conventional languages, dictionaries are implemented with auto-balanced trees or hashtables, which are highly performant, but also very complicated.

\subsection{Conventional Solutions}

\parahead{\Sal{}s}

The simplest representation for a dictionary, an \emph{\sal}, is merely a list of key-value pairs~\citep[Lists]{Pierce:SF1}.
%
Insertion and destruction are trivially achieved by the cons operator and pattern matching, respectively.
%
Lookup is only slightly more involved:
%
\begin{alltt}
  -- assumes that the key type K is fixed
  -- \altFAll\{V\} is an implicit type parameter
  assoc-list-lookup : \altFAll\{V\} \altRArr List (K \altTimes V) \altRArr K \altRArr Maybe V
  assoc-list-lookup [] \_ = None
  assoc-list-lookup ((k1 , v1) :: l) k =
    -- eq-dec-K returns Inl if its args are equal, Inr otherwise
    with eq-dec-K k k1
  ... | Inl \_ = Some v1
  ... | Inr \_ = assoc-list-lookup l k
\end{alltt}

Though easy to work with and reason about, \sal{}s have a drawback which can cause difficulty during proof development:
%
because they allow duplicate bindings for the same key and they are sensitive to the order of insertions, many distinct \sal{}s represent the same semantic mapping.
%
For example, the first two lines of \autoref{fig:intro-example}
%
show two distinct association lists (among others) that represent a dictionary with three particular bindings.
%
This lack of \firstUseGoal{\Extensional} can make proofs more difficult~\cite[Maps]{Pierce:SF1} or impossible, especially when it comes to proving \emph{contraction} and \emph{exchange}~\citep{StructProp}
%
as discussed further in \autoref{sec:CaseStudy} and \autoref{sec:Discussion:Generality}.

%% \input{fig-unequal}

\parahead{\Cals}

To establish a one-to-one correspondence between association lists and semantic mappings, one solution~\citep{FMapList} is to maintain a \emph{canonical}
%
form that is semantically valid and unique, namely, a list in which there are no duplicate keys and, furthermore, where keys are in sorted order.%
%
\footnote{\hspace{0.01in}%
%
The Coq standard library~\citep{FMapInterface}, describes unordered but deduplicated \sal{}s as ``weak,'' implying that \cal{}s are ``strong.''
%
}
%
The second association list shown in \autoref{fig:intro-example} is one such example.
%
This approach requires a more sophisticated \texttt{insert} function than that of the naive \sal{} approach:
\begin{alltt}
  -- assumes that the key type K is fixed
  cal-insert : \altFAll\{V\} \altRArr List (K \altTimes V) \altRArr (K \altTimes V) \altRArr List (K \altTimes V)
  cal-insert [] (k , v) = (k , v) :: []
  cal-insert ((k1 , v1) :: l) (k , v) =
    with ord-dec-K k k1
  ... | Inl \_       = (k , v) :: (k1 , v1) :: l         -- k < k1
  ... | Inr (Inl \_) = (k , v) :: l                      -- k == k1
  ... | Inr (Inr \_) = (k1 , v1) :: cal-insert l (k , v) -- k > k1
\end{alltt}

Despite being a bit more complicated, this approach has the benefit of being \extensional{}, in that if any two valid lists are not identical, they must have distinct semantic meanings.
%
The property of \SemInj{} is important for several reasons - in particular it permits the use of the built-in equality proposition to establish semantic equivalence.
%
Proof languages such as Agda have built-in support for \emph{reflexive equality}, which judges two values (of the same type) as being equal if and only if they are precisely identical:
\begin{alltt}
  -- In Agda, 'Set' is (roughly) the type of all types (incl. propositions).
  -- \_==\_ means that == is infix and binary.
  -- The first explicit arg is named x and is of type T,
  -- the second explicit arg is also of type T but is unnamed.
  -- Because == is a proposition, the "return type" is Set.
  data \_==\_ \{T : Set\} (x : T) : T \altRArr Set where
    -- A constructor of a proposition is a proof of that proposition.
    -- refl is the only constructor - for any x, refl is a proof that x == x.
    refl : x == x
    -- There's no way to establish equality of two arbitrary values x and y.
\end{alltt}

The built-in equality proposition is a common and intuitive way to judge the equality of two values.
%
Furthermore, proof assistants have special features for working with it, which can be harnessed to simlify and expedite proof development.
%
As such, it's very useful to be able to use this proposition, rather than to define a custom proposition that judges the semantic equivalence of two dictionaries.

Although the \cal{} approach is \extensional, it has another drawback; the list-of-pairs type allows arbitrary, possibly invalid lists, so each \cal{} must be packaged with a proof of validity:
\begin{alltt}
  -- assumes that the key type K is fixed
  data \_valid-cal \altFAll\{V\} (List (K \altTimes V)) : Set
    EmptyVal  : [] valid-cal
    SingleVal : \altFAll\{k v\} \altRArr ((k , v) :: []) valid-cal
    -- For any k1, k2, v1, v2, and l, if k1 < k2, and (k2 , v2) :: l is valid,
    -- then ManyVal stands as a proof that (k1 , v1) :: (k2 , v2) :: l is valid.
    ManyVal   : \altFAll\{k1 k2 v1 v2 l\} \altRArr
                  k1 < k2 \altRArr
                  ((k2 , v2) :: l) valid-cal \altRArr
                  ((k1 , v1) :: (k2 , v2) :: l) valid-cal

  cal : \altFAll\{V\} \altRArr Set
  -- '\altSum[ x \altIn T ] (p x)' packages x (of type T) with a proof that it satisfies p
  cal \{V\} = \altSum[ l \altIn List (K \altTimes V) ] (l valid-cal)
\end{alltt}

This paper coins the term \firstUseGoal{\semanticallyTotal} to describe any data structure whose type is free of proof terms and yet contains no invalid members -
%
\ie{} the mapping from values in the underlying type to their semantic meanings is total.
%
To illustrate, a pair of integers is not a \semanticallyTotal{} data structure for the rational numbers, since if the second integer is $0$ then the pair is invalid,
%
but a pair of an integer and a natural, where the natural represents the denominator minus $1$, \emph{is} \semanticallyTotal{} (note that neither of these data structures is \extensional).
%
The downsides of having to use validity proofs are discussed further in \autoref{sec:CaseStudy} and \autoref{sec:Discussion:Generality}.

\parahead{\Fpfs}

A third conventional solution is to represent dictionaries as finite partial functions~\cite[Maps]{Pierce:SF1} (\ie{} functions that return \texttt{None} for all but finitely many inputs).
%
The third line of \autoref{fig:intro-example} depicts a nested $\lambda$-expression that serves as the ``lookup table'' (we omit the \texttt{Some} constructors for space).
%
This approach can be made \extensional{} by postulating \emph{functional extensionality}~\mbox{\cite[Logic]{Pierce:SF1}}, which axiomatically asserts that $(\forall x, f(x) == g(x)) \Rightarrow f == g$.
%
On the other hand, this approach technically fails to satisfy \SemTot, since the function type permits \emph{non-}finite maps.
%
Even so, this is often not a problem in practice -- as long as the dictionary is never iterated, destructed, or counted, an infinite dictionary is indistinguishable from a finite dictionary.
%
Furthermore, a dictionary built from a finite program can only have finitely many mappings.
%
The more serious problem is that, unlike either association list approach, functions lack \firstUseGoal{\DecidableEq} and cannot be \firstUseGoal{\destructed}.

While a proof that $x == y$ establishes the truth that $x$ and $y$ are equal, the \texttt{==} proposition is not capable of \emph{deciding} whether or not two arbitrary values are equal.
%
To \emph{decide} this question, we need to define a function that accepts two arguments (of the same type) and returns either a proof that they are equal or a proof that they are not equal:
\begin{alltt}
  -- 'P \altRArr \altBot' means that P is false.
  eq-dec-K : (x y : K) \altRArr ((x == y) \altOr (x == y \altRArr \altBot))
  eq-dec-K x y = ?  --  the implementation will depend on the type K
\end{alltt}

Note that proof languages like Coq and Agda are \emph{constructive}; they elide the \emph{law of the excluded middle}, so it's possible for a proposition to be neither provably true nor provably false.
%
As such, the ability to decide whether some proposition (such as the equality of two values) is true or false cannot be taken for granted -- if this ability is needed, it must be explicitly established by defining a function such as the one above.
%
In the case of functions, it's not possible to establish that two arbitrary functions are unequal, so there is no way to establish decidability.
%
Naturally, deciding whether or not two dictionaries are equal is important and useful for many of the same reasons it would be in a more conventional language, so the lack of \DecidableEq{} is a substantial weakness.

The inability to destruct a function is more intuitive -- destruction is essentially the same as in other functional languages, where pattern-matching is typically used to separate one element of a collection (often the \emph{head}) from the rest of the collection.
%
A lambda value can't be destructed or picked apart in any way, so its values also can't be iterated or counted.
%
The function could be packaged with a set indicating its domain --- \ie{}~a canonical list of keys --- but would then have to include a proof that those keys are correct, violating \SemTot{} in the same troublesome way that \cal{}s do.

\subsection{Core Properties}

In some cases, the aforementioned drawbacks are minor or can be worked around.
%
But developing large proofs is challenging, so any stumbling block can cause exorbitant increases in verbosity, time, effort, and accidental complexity.
%
Furthermore, as shown in \autoref{sec:CaseStudy}, there are cases where these drawbacks make a proof task not merely difficult, but outright impossible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \rkc{Part 1.2: Summary of Design Goals. Editing TBD.}

Ideally, when working in a proof assistant, an implementation of a data structure---dictionaries in particular for this paper---would satisfy the following properties:

\newcommand{\designGoal}[1]
  {\textbf{\emph{#1:}}}

\begin{enumerate}

\item
%
\designGoal{\SemTot}
%
Every value in the representation type is semantically valid, \ie{}~the mapping from values to their semantic meanings is total.

\item
%
\designGoal{\SemInj}
%
Built-in equality corresponds to semantic equivalence, \ie{} two unequal values have different semantic meanings.

\item
%
\designGoal{\EqDec}
%
Built-in equality is decidable for the representation type.

\end{enumerate}

Furthermore, in addition to properties about the external interface of the data structure, it is often useful to retain the ability to inspect, iterate, and manipulate sub-dictionaries.
%
%% Thus, our final design goal:

\begin{enumerate}

\item[(4)]
%
\designGoal{\EzDstr}
%
The ability to decompose a data structure into atomic subparts in a convenient manner.

%% to facilitate

%% sufficiently

\end{enumerate}

\input{fig-summary}

\autoref{fig:prop-summary} summarizes the preceding discussion along these dimensions; note that the association list representations can be easily destructed, but destruction is not possible for \fpf{}s.
%
None of the conventional approaches satisfies both \SemTot{} and \SemInj{}, nor more than three of the four properties.

\subsection{Novel Solution: Delta Dictionaries}
%
The four core properties can be (mostly) satisfied by way of \emph{\dds{}} -- although destructible, \EzDstr{} is not fully achieved because destruction of \dds{} is awkward.
%
%% A \dd{} is similar to a canonical association list, but instead of storing each literal key value, it stores the \emph{difference} from the previous key, minus 1.
%
A \dd{} can be described as a ``canonical-by-construction'' association list: instead of storing each literal key value, it stores the \emph{difference} from the previous key, minus 1 (details in \autoref{sec:DD}).
%
For example, compare the canonical association list and \dd{} in \autoref{fig:intro-example}:

\vsepRule

%% keep this in sync with Figure 1
\begin{tabular}{ l l }
 \Cal{} & [(1, \str{a}), (3, \str{b}), (6, \str{c})] \\
 \Dd{}  & [(1, \str{a}), (1, \str{b}), (2, \str{c})]
\end{tabular}

\vsepRule

Every well-typed list-of-pairs is a valid \dd{}, thus no proof term is needed to establish validity (\SemTot).
%
Every unique \dd{} represents a unique semantic mapping, thus built-in equality may be used for semantic equivalence (\SemInj).
%
%% there is a bijection between \dd{} terms and finite maps,
%
Furthermore, we define a function which determines whether or not two \dds{} are equal (\EqDec), and a \texttt{destruct} function, which permits destruction albeit in a more awkward manner than standard pattern matching.

As summarized in \autoref{fig:prop-summary}, delta dictionaries strike a new balance in this design space.
%
Compared to \cal{}s, \dds{} enjoy \SemTot{}---the lone property among those we identify which the \cal{} does not.
%
However, destruction and iteration for \dds{} is substantially more difficult.
%
Furthermore, unlike all of the conventional approaches, \dds{} require a bijection to the naturals, not merely decidable equality or ordering, for their key types.
%
%% Our definition and implementation uses natural numbers for keys, and we illustrate how to use bijections to the naturals as a way of supporting strings, integers, or other key types that can be bijected to the naturals without great difficulty.
%
Lastly, though not a concern from a client's perspective, the implementation of delta dictionaries is considerably more involved than the conventional approaches.

%% than it is with the {\SAL}s or {\CAL}s, for which these operations are trivial ({\FPF}s cannot be properly destructed at all).

%% Naturally, \dds~ have some drawbacks as well.

%% Although most types that are suitable for use as keys in the first place can be bijected to the
%% naturals, for some types defining this bijection may be too awkward or cumbersome, in which case \dds~ may
%% be a poor choice.

%% As with the drawbacks of the other solutions, this one is
%% discussed further in the \nameref{sec:Problem} section.

\subsection{Outline}
%
%% Next, we describe the core operations for delta dictionaries in \autoref{sec:DD} and the relevant metatheory in \autoref{sec:DD:props}.
%
Next, we describe the core operations for delta dictionaries and the relevant metatheory in \autoref{sec:DD}.
%
In \autoref{sec:CaseStudy}, we describe a small case study in proof development that demonstrates the necessity of delta dictionaries.
%
Finally, we conclude in \autoref{sec:Discussion} with a discussion. %% of related work.
%
%% Our implementation and proofs are formalized in Agda and available in the anonymous supplementary materials.


%% {\color{gray}
%% 
%% \subsection{\rkc{Grab Bag of Text}}
%% 
%% %% \section{Problem}
%% %% \subsection{Problem}
%% %% \label{sec:Problem}
%% 
%% \rkc{1}
%% 
%% Data structures can possess or lack a wide range of properties that make them easier or harder to work with
%% when proving metatheory. Naturally, when possible, data structures should be chosen that posess those
%% properties which make the task at hand easier. Achieving this requires identifying the valuable properties,
%% what it is that makes them valuable, and finding or inventing data structures which possess those properties.
%% We hold that this is a broad topic of
%% research, which we illustrate in the particular context of choosing an implementation for a dictionary. In
%% this context, we identify, according to both conceptual and practical considerations, four important and
%% discriminating properties that a dictionary implementation may or may not possess:
%% TODO there's a good chance some of these properties have been named somewhere else. We should make sure we
%% don't try and coin terms for anything that's already been defined somewhere.
%% 
%% % TODO we may decide that the conceptual and practical benefits of decidable equality are so obvious or
%% % self-evident that we don't need any further discussion of that property
%% 
%% %% \subsection{Conceptual Importance}
%% %% \label{sec:Problem:concept}
%% 
%% \rkc{2}
%% 
%% In \autoref{sec:Problem:pract}, we illustrate practical problems and benefits under the particular context
%% of choosing an implementation for dictionaries. But first, it's worth exploring conceptual aspects that
%% apply to the general case. These conceptual aspects capture the spirit of practical considerations and
%% motivate the search for solutions that are not merely serviceable but elegant, moral, and insightful.
%% 
%% \subsubsection{\SemTot}
%% \label{sec:Problem:concept:SemTot}
%% TODO something something "making impossible states impossible", i think allusion to the right parts out of that
%% video will suffice to make the point here
%% 
%% \subsubsection{\SemInj}
%% \label{sec:Problem:concept:SemInj}
%% TODO something something it yields arbitrariness, which is not always wrong but which is unaesthetic and, when
%% avoidable, undesirable. It also allows for a semantic meaning to be represented by a concrete thing that is
%% needlessly verbose and complicated.
%% 
%% \subsubsection{\EqDec}
%% \label{sec:Problem:concept:EqDec}
%% The languages of proof assistants generally pride themselves on being total and constructive, on emphasizing
%% the knowable and demonstrable over the mysterious and hypothetical.
%% 
%% \subsubsection{\EzDstr}
%% \label{sec:Problem:concept:EzDstr}
%% TODO We need to clearly explain what we're talking about here, and clarify stuff like "facilitate inspection"
%% and "unrestricted non-additive manipulation". Aside from these clarifications, we won't say much else - in
%% this case the conceptual value largely boils down to the practical value.
%% 
%% %Finally, because they guarantee the \emph{structural properties} \emph{contraction} and
%% %\emph{exchange}, \dds~ are inherently inappropriate for substructural logics/judgments that reject one or
%% %both of those properties. In these cases, the naive solution's sensitivity to duplication and/or ordering is
%% %a feature, not a bug, and that solution becomes not only the natural solution but the morally correct one.
%% %Future work could explore the possibility of data structures that uphold one of these properties but not the
%% %other.
%% 
%% }
