% !TEX root = ?.tex

%% no citations in Abstract
%%
%% \cite{?}

\begin{abstract}

Dictionaries, or finite maps, are a core data structure in any programming language.
%
General-purpose languages implement dictionaries with hash tables or balanced trees, but proof assistants---which favor simplicity and provability over performance---generally employ association lists or finite partial functions.
%
Though suitable for many uses, each solution has drawbacks:
%
association lists allow arbitrary order and may contain duplicates (unless refined with an explicit proof about validity), and
%
partial functions cannot be compared for equality
%
nor easily destructed.

We develop a novel list-based representation, called \emph{delta dictionaries}, that simultaneously achieves benefits of the conventional representations.
%
Delta dictionaries are \emph{total} (every type-correct list is semantically valid),
%
\emph{extensional} (there is a one-to-one correspondence between lists and semantic mappings), and
%
\emph{destructible} (the internal representation can be inspected as needed).
%
We present the implementation of delta dictionaries and relevant metatheory---formalized in Agda---and we discuss when delta dictionaries may or may not be preferable to conventional solutions.

%% Using a variant of delta-encoding, we develop a novel list-based solution that preserves
%% canonical ordering while ensuring that every type-correct list is semantically valid, eliminating the need for refinement
%% with a proof of validity. Our solution also establishes a one-to-one correspondence between dictionary terms and semantic
%% mappings. We demonstrate the practical importance of these properties when developing metatheory for environment-based
%% evaluation semantics, while acknowledging that drawbacks of our solution may make it inferior to one of the conventional
%% solutions in some cases where that conventional solution is viable. We prove the relevant metatheory in Agda.

%
% Our solution is not suitable for all key types, and is harder to destruct or
%iterate than other list-of-pair solutions, but is nonetheless better suited to many large, complex program
%foundations metatheories than the existing solutions.
%
% Although easy to define and reason about, this approach has the disadvantage that keys
%can be duplicated, leading to the fact that many distinct lists represent the same semantic mapping.
%This many-one relationship creates various difficulties when used in practice, such as when proving
%contraction and exchange for a type-checking judgment.

\end{abstract}
